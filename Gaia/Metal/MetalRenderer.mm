//
//  MetalRenderer.mm
//  Gaia
//
//  Created by Alex Richardson on 04/06/2020.
//  Copyright Â© 2020 Alex Richardson. All rights reserved.
//

@import simd;
@import MetalKit;

#import "MetalRenderer.h"
#import "MetalShaderTypes.h"

#import "image_parameters.h"

// This class performs Metal setup and per-frame rendering

extern std::shared_ptr<Image> image;
extern std::shared_ptr<Flags> flags;

// Main class that performs the rendering
@implementation MetalRenderer{
    
    // The device (GPU) used to render
    id<MTLDevice> _device;
    
    // The render pipeline, generated by frag and vert shaders in .metal shader files.
    id<MTLRenderPipelineState> _pipelineState;
    
    // Command queue for passing commands to the device
    id<MTLCommandQueue> _commandQueue;
    
    // The metal texture object
    id<MTLTexture> _texture;
    
    // The Metal buffer that holds vertex data
    id<MTLBuffer> _vertices;
    
    // The number of vertices in the vertex buffer
    NSUInteger _numVertices;
    
    // The size of the view, for sending to the vert shader
    vector_uint2 _viewportSize;
}

// Fetch the texture from the render buffer in image_parameters
- (id<MTLTexture>)fetchTexture{
    
    MTLTextureDescriptor *textureDescriptor = [[MTLTextureDescriptor alloc] init];
    
    // Set texture pixel format to RGBA, each component being a 4-byte float
    textureDescriptor.pixelFormat = MTLPixelFormatRGBA32Float;
    
    // Set the pixel dimensions of the texture
    textureDescriptor.width = image->xDim;
    textureDescriptor.height = image->yDim;
    
    // Create the texture
    id<MTLTexture> texture = [_device newTextureWithDescriptor:textureDescriptor];
    
    // Calculate the number of bytes per row in the image
    // 4 bytes * 3 components * pixels
    NSUInteger bytesPerRow = 12 * image->xDim;
    
    MTLRegion region = {
        { 0, 0, 0 }, // MTLOrigin
        { (unsigned long)image->xDim, (unsigned long)image->yDim, 1} // MTLSize
    };
    
    // Copy the bytes into the texture
    [texture replaceRegion:region
               mipmapLevel:0
                 withBytes:image->output_array
               bytesPerRow:bytesPerRow];
    
    return texture;
}

// Init
- (nonnull instancetype)initWithMetalKitView:(nonnull MTKView *)mtkView{
    
    self = [super init]; // Chain initializer, inherit from NSView
    if(self){ // If the initialization failed somewhere, don't try to carry on.
        
        NSError *error = NULL;
        
        // Get the device
        _device = mtkView.device;

        // Fetch the resolution of the display (this is scaled resolution)
        NSScreen *mainScreen = [NSScreen mainScreen];
        NSRect screenRect = [mainScreen visibleFrame];
        
        int xDim = screenRect.size.width;
        int yDim = screenRect.size.height;
        
        // While maintaining the correct aspect ratio, scale the image to fit on the screen
        if (image->nx > xDim)
        {
            yDim = (float(image->ny) / float(image->nx)) * float(xDim);
        }
        else if (image->ny > yDim)
        {
            xDim = (float(image->nx) / float(image->ny)) * float(yDim);
        }
        else {
            xDim = image->nx;
            yDim = image->ny;
        }
        
        // The origin is in the centre of the view, must offset vertex positions accordingly
        float halfX = (float)xDim * 0.5f;
        float halfY = (float)yDim * 0.5f;
        
        // Our vertices and their texture coords
        static const MetalVertex quadVertices[] = {
            // 2D positions,   Texture coordinates
            { {  halfX, -halfY }, { 1.0f, 0.0f } },
            { { -halfX, -halfY }, { 0.0f, 0.0f } },
            { { -halfX,  halfY }, { 0.0f, 1.0f } },
            
            { {  halfX, -halfY }, { 1.0f, 0.0f } },
            { { -halfX,  halfY }, { 0.0f, 1.0f } },
            { {  halfX,  halfY }, { 1.0f, 1.0f } },
        };
        
        // Create the render pipeline
        
        // Create a vertex buffer, initialized with the quadVertices array
        
        _vertices = [_device newBufferWithBytes:quadVertices
                                         length:sizeof(quadVertices)
                                        options:MTLResourceStorageModeShared];
        
        _numVertices = sizeof(quadVertices) / sizeof(MetalVertex);
        
        
        // Load all the shader files with a .metal extension in the project.
        id<MTLLibrary> defaultLibrary = [_device newDefaultLibrary];
        
        id<MTLFunction> vertexFunction = [defaultLibrary newFunctionWithName:@"vertexShader"]; // retrieve the function labelled vertexShader from the .metal file as the vert shader.
        
        id<MTLFunction> fragmentFunction = [defaultLibrary newFunctionWithName:@"fragmentShader"]; // same with frag shader
        
        // Configure a pipeline descriptor, which is used to create a pipeline state.
        // If not set up correctly, creation of the pipeline state could fail.
        
        MTLRenderPipelineDescriptor *pipelineStateDescriptor = [[MTLRenderPipelineDescriptor alloc] init];
        pipelineStateDescriptor.label = @"Texturing Pipeline";
        pipelineStateDescriptor.vertexFunction = vertexFunction;
        pipelineStateDescriptor.fragmentFunction = fragmentFunction;
        pipelineStateDescriptor.colorAttachments[0].pixelFormat = mtkView.colorPixelFormat;
        
        _pipelineState = [_device newRenderPipelineStateWithDescriptor:pipelineStateDescriptor  error:&error];
        
        NSAssert(_pipelineState, @"Failed to create pipeline state: %@", error);
        
        // Create the command queue
        _commandQueue = [_device newCommandQueue];
    }
    
    return self;
}

// Called whenever the view is resized
- (void)mtkView:(nonnull MTKView *)view drawableSizeWillChange:(CGSize)size{
    
    // Save the size of the drawable to pass to the vertex shader
    _viewportSize.x = size.width;
    _viewportSize.y = size.height;
}

// The render function, called whenever the view needs to render a frame
- (void)drawInMTKView:(nonnull MTKView *)view{

    // Update the texture!
    _texture = [self fetchTexture];

    // id is a pointer to any Objective-C object, like void*
    // Create a new command buffer for each render pass to the current drawable
    id<MTLCommandBuffer> commandBuffer = [_commandQueue commandBuffer];
    commandBuffer.label = @"MyCommand";
    
    // This references the texture into which Metal should draw
    MTLRenderPassDescriptor *renderPassDescriptor = view.currentRenderPassDescriptor;
    if (renderPassDescriptor == nil){
        return;
    }
    
    if(renderPassDescriptor != nil){

        // Use the renderPassDescriptor to create a render command encoder
        id<MTLRenderCommandEncoder> commandEncoder = [commandBuffer renderCommandEncoderWithDescriptor:renderPassDescriptor];
        commandEncoder.label =@"MyRenderEncoder";
        
        // Set the region of the drawable to draw into
        [commandEncoder setViewport:(MTLViewport){0.0, 0.0, static_cast<double>(_viewportSize.x), static_cast<double>(_viewportSize.y), -1.0, 1.0 }];
        
        [commandEncoder setRenderPipelineState: _pipelineState];
        
        // Pass in the parameter data
        [commandEncoder setVertexBuffer:_vertices
                                 offset:0
                                atIndex:VertexInputIndexVertices];
        
        [commandEncoder setVertexBytes:&_viewportSize
                                length:sizeof(_viewportSize)
                               atIndex:VertexInputIndexViewportSize];
        
        // Set the texture object.
        [commandEncoder setFragmentTexture:_texture
                                   atIndex:TextureIndexBaseColor];
        
        // Draw the triangles
        [commandEncoder drawPrimitives: MTLPrimitiveTypeTriangle
                           vertexStart:0
                           vertexCount:_numVertices];
        
        // End encoding. This causes the drawable to be cleared.
        [commandEncoder endEncoding];
        
        // Get the drawable that will be presented
        id<MTLDrawable> drawable = view.currentDrawable;
        
        // Request the drawable to be presented by the windowing system once drawn
        [commandBuffer presentDrawable:drawable];
        
    }
    // Commit command buffer to GPU
    [commandBuffer commit];
    
}

@end
